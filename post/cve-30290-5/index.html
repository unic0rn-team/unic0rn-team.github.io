<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        CVE-2022-30190 &#34;Follina&#34; - part 4 ::
        unic0rn-team&#39;s billets — unic0rn-team&#39;s musings
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="#Billet 5 TL;DR L&amp;rsquo;existence d&amp;rsquo;une vulnérabilité ne signifie pas nécessairement qu&amp;rsquo;un adversaire a les connaissances ou les compétences pour l&amp;rsquo;exploiter. Cependant lorsque des données additionnelles émergent sous la forme des exploits publiés qui facilitent significativement son utilisation, l&amp;rsquo;analyse du contexte et du mode opératoire (&amp;ldquo;TTPs&amp;rdquo;) des TA met en perspective la criticité de celle-ci, . C&amp;rsquo;est également le cas de la &amp;ldquo;Follina&amp;rdquo; qui, depuis son publication, ne cesse pas de forcer à un rehaussement du niveau de risque à cause de son adoption par des différents attaquants avec des motivations et des modes opératoires divergentes."
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://unic0rn-team.github.io/post/cve-30290-5/" />





<link rel="stylesheet" href="https://unic0rn-team.github.io/assets/style.css" />

<link rel="stylesheet" href="https://unic0rn-team.github.io/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="https://unic0rn-team.github.io/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="https://unic0rn-team.github.io/img/favicon.png" />


<link href="https://unic0rn-team.github.io/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://unic0rn-team.github.io/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://unic0rn-team.github.io/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://unic0rn-team.github.io/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://unic0rn-team.github.io/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://unic0rn-team.github.io/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2022-30190 &#34;Follina&#34; - part 4"/>
<meta name="twitter:description" content="#Billet 5 TL;DR L&rsquo;existence d&rsquo;une vulnérabilité ne signifie pas nécessairement qu&rsquo;un adversaire a les connaissances ou les compétences pour l&rsquo;exploiter. Cependant lorsque des données additionnelles émergent sous la forme des exploits publiés qui facilitent significativement son utilisation, l&rsquo;analyse du contexte et du mode opératoire (&ldquo;TTPs&rdquo;) des TA met en perspective la criticité de celle-ci, . C&rsquo;est également le cas de la &ldquo;Follina&rdquo; qui, depuis son publication, ne cesse pas de forcer à un rehaussement du niveau de risque à cause de son adoption par des différents attaquants avec des motivations et des modes opératoires divergentes."/>



<meta property="og:title" content="CVE-2022-30190 &#34;Follina&#34; - part 4" />
<meta property="og:description" content="#Billet 5 TL;DR L&rsquo;existence d&rsquo;une vulnérabilité ne signifie pas nécessairement qu&rsquo;un adversaire a les connaissances ou les compétences pour l&rsquo;exploiter. Cependant lorsque des données additionnelles émergent sous la forme des exploits publiés qui facilitent significativement son utilisation, l&rsquo;analyse du contexte et du mode opératoire (&ldquo;TTPs&rdquo;) des TA met en perspective la criticité de celle-ci, . C&rsquo;est également le cas de la &ldquo;Follina&rdquo; qui, depuis son publication, ne cesse pas de forcer à un rehaussement du niveau de risque à cause de son adoption par des différents attaquants avec des motivations et des modes opératoires divergentes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://unic0rn-team.github.io/post/cve-30290-5/" />
<meta property="article:published_time" content="2022-07-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-07-23T00:00:00+00:00" /><meta property="og:site_name" content="unic0rn-team&#39;s billets" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="https://unic0rn-team.github.io/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >hello friend</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/archive">Archive</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/archive">Archive</a></li>
      
    
      
        <li><a href="/showcase">Showcase</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">CVE-2022-30190 &ldquo;Follina&rdquo; - part 4</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2022-07-23
        </span>

        
          
        
      

      
        <span class="post-author"
          >— Written by unic0rn-team</span
        >


      
    </div>

    

    

    <div class="post-content">
      
      <h2 id="billet-5">#Billet 5</h2>
<h3 id="tldr"><strong>TL;DR</strong></h3>
<p>L&rsquo;existence d&rsquo;une vulnérabilité ne signifie pas nécessairement qu&rsquo;un adversaire a les connaissances ou les compétences pour l&rsquo;exploiter. Cependant lorsque des données additionnelles émergent sous la forme des exploits publiés qui facilitent significativement son utilisation, l&rsquo;analyse du contexte et du mode opératoire (&ldquo;TTPs&rdquo;) des TA met en perspective la criticité de celle-ci, . C&rsquo;est également le cas de la &ldquo;Follina&rdquo; qui, depuis son publication, ne cesse pas de forcer à un rehaussement du niveau de risque à cause de son adoption par des différents attaquants avec des motivations et des modes opératoires divergentes.</p>
<p>Utilisé presque exclusivement comme vecteur d&rsquo;attaque initial, &ldquo;Follina&rdquo; peut ressusciter et donner du punch à des pièces de malware communs (&quot;<em>commodity malware</em>&quot;). C&rsquo;est a un tel échantillon qu&rsquo;on va s&rsquo;y intéresser ici en essayant de découvrir comment son adoption à influencé le mode opératoire de l&rsquo;adversaire.</p>
<h3 id="5follina--rozena"><strong>5.Follina &amp; Rozena</strong></h3>
<p>Le 6 Juillet 2022 des chercheurs de <a href="https://www.fortinet.com/blog/threat-research/follina-rozena-leveraging-discord-to-distribute-a-backdoor">Fortinet</a> décrivent une campagne utilisant Follina comme point d&rsquo;entrée pour <strong>Rozena</strong>, un malware s&rsquo;exécutant en mémoire (&quot;<em>fileless backdoor</em>&quot;), capable d&rsquo;injecter une connexion shell à distance vers la machine de l&rsquo;attaquant depuis la machine victime (&quot;<em>reverse shell</em>&quot;). Celui-ci à été décrit et analysé en détail par équipe de <a href="https://www.gdatasoftware.com/blog/2018/06/30862-fileless-malware-rozena">G Data</a> en 2018. Depuis on le retrouve associé sporadiquement aux malwares comme Gozi, WinGo, Cobalt Strike et même une version (<a href="https://www.virustotal.com/gui/file/3782e0dedbfe37028a0848f9cce0647083dade4969e3ca2edde847536c76652d">3782e0dedbfe37028a0848f9cce0647083dade4969e3ca2edde847536c76652d</a>) codé en Python et ciblant les machines sous Linux.</p>
<p>Le document malicieux initial est livré comme souvent en pièce jointe à un mail de phishing  sous la forme d&rsquo;un document Word (<a href="https://www.virustotal.com/gui/file/432bae48edf446539cae5e20623c39507ad65e21cb757fb514aba635d3ae67d6">432bae48edf446539cae5e20623c39507ad65e21cb757fb514aba635d3ae67d6</a>)</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg126.png" alt=""></p>
<p><em><strong>Figure 1:</strong></em> <em>Le document distribué en pièce jointe d&rsquo;un mail</em></p>
<p>Comme dans le cas du démonstrateur vu ensemble, le fichier <em>word/_rels/document.xml.rels</em> qui à le rôle de mettre en correspondance les relations au sein du fichier .docx avec les ressources extérieures,  contient un lien de téléchargement du <strong>index.htm</strong> depuis <em>cdn.discordapp.com</em> - technique connue sous le nom de <strong>HTML smuggling</strong> :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg128.png" alt=""></p>
<p><em><strong>Figure2:</strong></em> <em>Contenu du document.xml.rels</em></p>
<p>Le fichier <strong>index.htm</strong> (<a href="https://www.virustotal.com/gui/file/3558840ffbc81839a5923ed2b675c1970cdd7c9e0036a91a0a728af14f80eff3">3558840ffbc81839a5923ed2b675c1970cdd7c9e0036a91a0a728af14f80eff3</a>) invoque msdt à travers PowerShell</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg129.png" alt=""></p>
<p><em><strong>Figure 3:</strong></em> <em>Le document index.htm téléchargé depuis cdn.discordapp.com</em></p>
<p>Pour cela il utilise une obfuscation par concaténation des chaînes de caractères (&ldquo;strings&rdquo;) en base64 :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg130.png" alt=""></p>
<p><em><strong>Figure 4:</strong></em> <em>Obfuscation de l&rsquo;exploit Follina</em></p>
<p>Une fois décodé on obtient la commande complète :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg131.png" alt=""></p>
<p><em><strong>Figure 5:</strong></em> <em>Commande pour télécharger le second stage</em></p>
<p>Celle-ci téléchargera, à l&rsquo;aide de cmdlet PowerShell <strong>Invoke-webRequest</strong> (&quot;<em>iwr</em>&quot;), depuis le même channelID du serveur Discord, un script batch (&quot;<strong>cd.bat</strong>&quot;) et un exécutable (&quot;<strong>Word.exe</strong>&quot;) les sauvegardant dans le répertoire <em>\Windows\Tasks.</em></p>
<p>Avec cela la première étape de l&rsquo;attaque, la mise en scene (&quot;<em>staging</em>&quot;) est finalisé. Il est intéressant de noter ici, à côté de l&rsquo;emploi d&rsquo;une forme d&rsquo;obfuscation, l&rsquo;utilisation des services Discord comme serveurs C2 afin de réduire la probabilité de la détection. On s&rsquo;interesse maintenant à la deuxième étape du kill-chain (&quot;<em>second stage</em>&quot;).</p>
<p>Le script batch <strong>cd.bat</strong> (<a href="https://www.virustotal.com/gui/file/5d8537bd7e711f430dc0c28a7777c9176269c8d3ff345b9560c8b9d4daaca002">5d8537bd7e711f430dc0c28a7777c9176269c8d3ff345b9560c8b9d4daaca002</a>) exhibe le comportement suivant :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg132.png" alt=""></p>
<p><strong>Figure 6:</strong>* *Le script cd.bat*</p>
<ul>
<li>Télécharger un fichier (<a href="https://www.virustotal.com/gui/file/e3af143ba12209fafdc3089a740d23faf59f6f1508c00d8f56f8cc9d0c8ebf89">e3af143ba12209fafdc3089a740d23faf59f6f1508c00d8f56f8cc9d0c8ebf89</a>) et le sauvegarder comme <strong>18562.docx</strong></li>
<li>Tuer les process &ldquo;msdt.exe&rdquo; et &ldquo;Winword.exe&rdquo; pour effacer la trace de l&rsquo;exploitation du CVE-2022-30190</li>
<li>Créer la persistance pour &ldquo;<strong>Word.exe</strong>&rdquo; par le rajout des clefs &ldquo;run&rdquo; dans la base de régistres</li>
<li>Supprimer le fichier bat</li>
</ul>
<p>Le fichier <strong>18562.docx</strong> contenant un nombre d&rsquo;images est complètement inoffensif. Il met en oeuvre un premier niveau d&rsquo;indirection pour détourner l&rsquo;attention de la victime. Ce n&rsquo;est pas le cas de exécutable Word.exe stocké à côté.</p>
<p>Malgré son nom et son icône affichée (deuxième niveau d&rsquo;indirection) il s&rsquo;agit bel et bien d&rsquo;un <strong>fichier PE</strong> - binaire Windows (&ldquo;Portable Executable&rdquo;):</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg133.png" alt=""></p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg134.png" alt=""></p>
<p><em><strong>Figure 7:</strong></em> <em>Le binaire Word.exe</em></p>
<p>En s&rsquo;appuyant sur la similitude de la routine d&rsquo;infection décrite <a href="https://www.gdatasoftware.com/blog/2018/06/30862-fileless-malware-rozena">ailleurs</a> on émet l&rsquo;hypotese que le mode opératoire est celui du malware connu sous le nom de <strong>Rozena</strong>. Une analyse détaillé pourra nous confirmer cela.</p>
<p>En exécutant <strong>Word.exe</strong> (<a href="https://www.virustotal.com/gui/file/69377adfdfa50928fade860e37b84c10623ef1b11164ccc6c4b013a468601d88">69377adfdfa50928fade860e37b84c10623ef1b11164ccc6c4b013a468601d88</a>) dans un environnement contrôlé (analyse dynamique) on s&rsquo;aperçoit qu&rsquo;il lance un triplet de commandes PowerShell chacun appelant en cascade la commande suivante sous la forme d&rsquo;un blob en base64 décodé à la volée :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg136.png" alt=""></p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg135.png" alt=""></p>
<p><em><strong>Figure 8:</strong></em> <em>Exécution du binaire Rozena</em></p>
<p>Au bout de la chaîne on voit que la dernière commande est appelé avec le paramètre &ldquo;<strong>-ec</strong>&rdquo; (&quot;<em>EncodedCommand</em>&quot;) <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pwsh?view=powershell-7.2">utilisé</a> pour soumettre à PowerShell des commandes sous forme des strings en base64 :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg153.png" alt=""></p>
<p><em><strong>Figure 9:</strong></em> <em>Commende d&rsquo;encodage du script PowerShell</em></p>
<p>La variable <strong>$gcr</strong> contiendra des appelles à DLLImport pour les librairies kernel32.dll et msvcrt.dll afin d&rsquo;importer des API spécifiques : <a href="https://malapi.io/winapi/VirtualAlloc">VirtualAlloc</a>, <a href="https://malapi.io/winapi/CreateThread">CreateThread</a> et <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memset-wmemset?view=msvc-170">Memset</a>. Ces fonctions exportés par les dll sont couramment utilisées pour l&rsquo;<strong>exécution de shellcodes par injection</strong> : allocation de la mémoire, création d&rsquo;un thread d&rsquo;exécution dans l&rsquo;espace d&rsquo;adressage, création d&rsquo;un buffer mémoire. Il est désormais clair que la commande décodée n&rsquo;a qu&rsquo;un seul but : injecter le shellcode, c&rsquo;est à dire le octets hexadécimaux qui définissent le bloc de code dans le tableau Byte[], à travers la commande PowerShell :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg152.png" alt=""></p>
<p><em><strong>Figure 10:</strong></em> <em>Injection du shellcode</em></p>
<p>Le shellcode est une séquence d&rsquo;instructions CPU qui peut être interprétée et exécutée directement par le CPU. Le nom de shellcode provient du fait que les attaquants l&rsquo;utilisent généralement pour obtenir un accès shell interactif sur le système compromis. Cependant, au fil du temps, le terme est devenu communément utilisé pour décrire tout morceau de code exécutable autonome. Il est ainsi utilisé pour exécuter du code malveillant après l&rsquo;exploitation d&rsquo;une vulnérabilité, pour télécharger le second stage ou encore pour signaliser au serveur C2. Il convient donc de l&rsquo;extraire pour poursuivre notre investigation.</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg139.png" alt=""></p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg140.png" alt=""></p>
<p><em><strong>Figure 11:</strong></em> <em>Récupération du shellcode en format binaire</em></p>
<p>Dans le cas d&rsquo;une injection le shellcode est ajouté à un programme en exécution . Il est c&rsquo;est ce qu&rsquo;on appelle &ldquo;Position Independent Code&rdquo; (&ldquo;PIC&rdquo;) c&rsquo;est à dire code qui n&rsquo;utilise pas d&rsquo;adresses mémoire codées en dur pour se charger. Il en résulte que le PIC peut être exécuté n&rsquo;importe où dans la mémoire, sans aucun problème. La question qui se pose alors est : comment l&rsquo;injection marche ?</p>
<p>Pour pouvoir s&rsquo;injecter dans l&rsquo;espace mémoire d&rsquo;un programme en exécution,le shellcode doit obtenir la valeur stocké dans l&rsquo;EIP (&quot;<a href="http://www.c-jump.com/CIS77/ASM/Instructions/I77_0040_instruction_pointer.htm">Extended Instruction Pointer</a>&quot;) - un registre CPU qui suit où se trouvent dans la mémoire les instructions en cours d&rsquo;exécution - pour ensuite  l&rsquo;utiliser comme pointeur de base (&quot;<a href="https://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html">Base Pointer</a>&quot;) de la pile mémoire (&ldquo;stack&rdquo;). Pour rappel, celui-ci fait référence à la dernière valeur (la plus basse) de la pile qui grandit toujours vers le bas. Le shellcode doit donc <strong><a href="https://danielebellavista.blogspot.com/2014/10/ia32-shellcodes-get-eip-value.html">déréférencer un pointeur de base</a></strong> lorsqu&rsquo;il accède aux données d&rsquo;une manière indépendante de la position. L&rsquo;ajout ou la soustraction de valeurs (&quot;<em>relative offset</em>&quot;) à cette base lui permettra de s&rsquo;exécuter . Comme le jeu d&rsquo;instructions x86 ne permet la manipulation directe de  l&rsquo;EIP un registre ordinaire doit d&rsquo;abord être chargé avec la valeur de l&rsquo;EIP , pour être utilisé comme pointeur de base. En somme, obtenir l&rsquo;EIP n&rsquo;est pas toujours évident, car sur les systèmes x86 il ne peut pas être directement accédé.</p>
<p>Une des techniques utilisé pour contourner cela consiste dans l&rsquo;utilisation de l&rsquo;instruction <strong>fstenv</strong> pour stocker l'état du FPU (&quot;<em>Floating Point Unit</em>&quot;) en mémoire. L&rsquo;FPU contient un ensemble distinct de registres à usage spécial qui doivent être sauvegardés par le système d&rsquo;exploitation lors d&rsquo;un changement de contexte lorsque un processus effectue une opération arithmétique à virgule flottante. C&rsquo;est cette technique qui est employé par Rozena :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg143.png" alt=""></p>
<p><em><strong>Figure 12:</strong></em> <em>L&rsquo;instruction fnstenv</em></p>
<p>Le shellcode existe donc sous la forme d&rsquo;un blob binaire qui sera exécuté. Mais il doit faire quelque chose 
utile une fois qu&rsquo;il a été exécuté, ce qui signifie généralement interagir avec le système par le biais des API. Rappelez-vous que le shellcode ne peut pas utiliser le loader Windows pour s&rsquo;assurer que toutes les bibliothèques nécessaires sont chargées et disponibles, et pour s&rsquo;assurer que tous les symboles externes sont résolus. Pour être fiable le shellcode doit localiser dynamiquement les fonctions dans différents environnements, et pour cette tâche, il utilise généralement <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>  et <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> exportés par <strong>kernel32.dll</strong>. En émulant l&rsquo;execution de notre échantillon on peut vérifier ce comportement :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg144.png" alt=""></p>
<p><em><strong>Figure 13:</strong></em> <em>Emulation du shellcode</em></p>
<p>Ce shellcode démarrer un reverse shell vers l&rsquo;hôte de l&rsquo;attaquant <strong>microsofto.duckdns[.]org</strong> sur le port TCP <strong>55911</strong>. Comment sait-on qu&rsquo;il s&rsquo;agit d&rsquo;un revers shell ? Pour répondre à cette question on suit son chemin exécution ou très vite on trouve l&rsquo;empreinte d&rsquo;une forme d&rsquo;encodage utilisé par le framework offensif Metasploit : <strong>Shikata-Ga-Nai</strong>.</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg149.png" alt=""></p>
<p><em><strong>Figure 14:</strong></em> <em>Schéma d&rsquo;encodage Shikata-Ga-Nai</em></p>
<p>Shikata-Ga-Nai ( en japonaise &ldquo;on ne peut rien y faire&rdquo;) est une <strong>schéma d&rsquo;encodage XOR polymorphique</strong>. On se rappelle que XOR (&ldquo;exclusive OR&rdquo;) est un  algorithme de chiffrement additif avec lequel une chaîne de texte peut être chiffrée en appliquant l&rsquo;<a href="https://en.wikipedia.org/wiki/XOR_cipher">opérateur XOR</a> à chaque caractère en utilisant une clé donnée. Pour décrypter le résultat, il suffit de réappliquer la fonction XOR avec la clé pour obtenir le texte initial.Comme expliqué <a href="https://marcosvalle.github.io/re/exploit/2018/08/25/shikata-ga-nai.html">ici</a> : &ldquo;<em>Pour surmonter le problème du cryptage, à savoir le fait que le code du décrypteur est détectable, les auteurs ont mis en œuvre des techniques permettant de créer des décrypteurs mutants. Les <strong>virus polymorphes</strong> peuvent changer le code de leur décrypteur à chaque génération. Ils peuvent générer un grand nombre de décrypteurs distincts qui peuvent même utiliser une méthode de cryptage différente pour crypter le corps du virus.&quot;</em></p>
<p>Shikata-Ga-Nai (&ldquo;SGN&rdquo;) est donc un encodeur polymorphe :  en effet, en changeant la clé, on obtient différentes versions du code crypté, qui produisent le même code après décodage. Afin de tracer l&rsquo;exécution et visualiser ce comportement on génère un graph à l&rsquo;aide du ProcDot :</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg147.png" alt=""></p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg154.png" alt=""></p>
<p><em><strong>Figure 15:</strong></em> <em>Le chemin d&rsquo;exécution du shellcode</em></p>
<p>L&rsquo;exécution du shellcode passe par les étapes suivantes :</p>
<ol>
<li>Définir une clé  (le stocker dans le registre eax)</li>
<li>Obtenir EIP à l&rsquo;aide de l&rsquo;instruction fstenv suivi par la récupération de la valeur du registre ebx depuis le stack</li>
<li>Entrer dans un loop ou, pour chaque itération, on applique le XOR avec la clé sur ebx</li>
<li>Modifier la clé en l&rsquo;ajoutant au résultat de l&rsquo;instruction modifiée (opération additive)</li>
</ol>
<p>En vue de ces résultats notre hypothèse se confirme : on à affaire à un échantillon de Rozena qui à armé l&rsquo;exploit Follina comme tête de pont. On peut désormais reconstituer le kill-chain de cette campagne:</p>
<p><img src="C:%5CUsers%5CAdministrateur%5CDocuments%5CBlog%5Cimg%5Cimg155.png" alt=""></p>
<p><em><strong>Figure 16:</strong></em> <em>Le kill-chain de l&rsquo;infection avec Rozena</em></p>
<h3 id="conclusion"><strong>Conclusion</strong></h3>
<p>Rozena peut être considéré comme un exemple de ce qu&rsquo;on appelle &ldquo;<strong>fileless attack</strong>&quot;.  Il s&rsquo;agit d&rsquo;une technique d&rsquo;attaque qui ne nécessite pas de télécharger ou de déposer des fichiers malveillants dans le système pour exécuter sa charge malicieuse, mais qui s&rsquo;appuie plutôt sur des exploits pour lancer des commandes ou des scripts directement depuis la mémoire via des outils système légitimes (PowerShell, WMI). Toutefois, le terme &ldquo;sans fichier&rdquo; peut également être mal choisi, car certaines attaques peuvent impliquer la présence de fichiers sur l&rsquo;ordinateur, comme l&rsquo;ouverture d&rsquo;une pièce jointe d&rsquo;un courriel de spam. Une fois exécutée, elle peut encore enregistrer un fichier sur le disque et utiliser ensuite des techniques &ldquo;fileless&rdquo; pour recueillir des informations sur le système et propager l&rsquo;infection dans le réseau. Ces techniques peuvent prendre la forme d&rsquo;exploits et d&rsquo;injections de code directement dans la mémoire, stocker des scripts dans le registre et exécuter des commandes via des outils légitimes.</p>
<p>En choisissant l&rsquo;exploit Follina pour la première phase de l&rsquo;attaque assure une intervention minimale de la part de la victime. Ensemble avec les autres techniques d&rsquo;evasion, comme l&rsquo;utilisation des serveurs Discord en guise de C2, l&rsquo;implantation d&rsquo;un document Word inoffensif côte-à-côte avec le binaire malicieux qui porte lui aussi l&rsquo;icône et le nom Word, multiplieront les chances d&rsquo;une exécution réussie de l&rsquo;attaque Rozena.</p>
<p>Dans le paysage déjà assez riche de son &lsquo;utilisation, Follina offre encore des possibilités offensives non-négligeables, sur lesquelles on aura sans doute occasion de revenir.</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
            
              <span class="button next">
                <a href="https://unic0rn-team.github.io/post/cve-30190-4/">
                  <span class="button__text">CVE-2022-30190 &#34;Follina&#34; - part 4</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="https://unic0rn-team.github.io/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >hello friend</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span
          >© 2022 Powered by
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span
        >
        <span
          >Theme created by
          <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span
        >
      </div>
    
  </div>
</footer>

<script src="https://unic0rn-team.github.io/assets/main.js"></script>
<script src="https://unic0rn-team.github.io/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
